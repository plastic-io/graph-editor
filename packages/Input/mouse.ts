const shiftKeyCode = 16;
const metaKeyCode = 91;
const ctrlKeyCode = 17;
const spaceKeyCode = 32;
import type {Node} from "@plastic-io/plastic-io";
import type {Store} from 'pinia';
import {linkInnerNodeEdges} from "@plastic-io/plastic-io";
import {newId} from "@plastic-io/graph-editor-vue3-utils";
import {useStore as useOrchestratorStore} from "@plastic-io/graph-editor-vue3-orchestrator";
import {useStore as useCanvasStore} from "@plastic-io/graph-editor-vue3-canvas";
import {useStore as usePreferencesStore} from "@plastic-io/graph-editor-vue3-preferences-provider";

import {useStore as useInputStore} from "./store";
// import {applyGraphChanges, newId, updateBoundingRect, remapNodes} from "./mutations"; // eslint-disable-line
export default class MouseAction {
    inputStore: any
    orchestratorStore: any
    graphCanvasStore: any
    preferencesStore: any
  constructor() {
      this.inputStore = useInputStore();
      this.graphCanvasStore = useCanvasStore();
      this.orchestratorStore = useOrchestratorStore();
      this.preferencesStore = usePreferencesStore();
  }
  remapNodes(arr: any) {
    return this.graphCanvasStore.graph.nodes.filter((v: any) => {
      return arr.find((vi: any) => v.id === vi.id);
    });
  }
  applyGraphChanges(description: string) {
    this.graphCanvasStore.updateGraphFromSnapshot(description);
  }
  updateBoundingRect() {}
  mouse(mouse: any) {
    if (this.orchestratorStore.inRewindMode) {
        console.warn("No mouse based mutations during rewind mode");
        return;
    }
    const locked = this.orchestratorStore.presentation || this.orchestratorStore.locked;
    const ctrl = mouse.event.ctrlKey || mouse.event.metaKey;
    const shift = mouse.event.shiftKey;
    const gridSize = this.preferencesStore.preferences.snapToGrid && !shift ? this.preferencesStore.preferences.gridSize : 1;
    const addKey = shift || ctrl;
    const pastDeadZone = this.graphCanvasStore.translating.mouse ? (Math.abs(mouse.x - this.graphCanvasStore.translating.mouse.x) > 2
        || Math.abs(mouse.y - this.graphCanvasStore.translating.mouse.y) > 2) : false;
    // TODO: This whole grouping thing seems suspect.
    // Might need to reimagine how it works.  Moving on.
    const expandGroupNodeArray = (arr: any[]) => {
        let addCount = 0;
        // gather items in related groups
        const groupIds: string[] = [];
        // HACK: sometimes this array is populated with an empty member, not sure why, needs a fix
        arr.filter(v => !!v).forEach((v: Node) => {
            groupIds.push(...v.properties.groups);
        });
        this.graphCanvasStore.graph.nodes.forEach((v: Node) => {
            if (v.properties.groups.find((value: string) => groupIds.includes(value)) && arr.indexOf(v) === -1) {
                addCount += 1;
                arr.push(v);
            }
        });
        if (addCount > 0) {
            expandGroupNodeArray(arr);
        }
    };
    const remapHovered = () => {
        return this.graphCanvasStore.graph.nodes.find((v: Node) => {
            return this.graphCanvasStore.hoveredNode.id === v.id;
        });
    }
    // check if the mouse is hovering over any connectors using LUTs generated by bezier.ts plugin
    let x = (mouse.x - this.graphCanvasStore.view.x) / this.graphCanvasStore.view.k;
    let y = (mouse.y - this.graphCanvasStore.view.y) / this.graphCanvasStore.view.k;
    let m = 5;
    // map LUTs for collions
    const luts = Object.keys(this.orchestratorStore.luts).map((connectorId: string) => {
        return {
            output: this.orchestratorStore.luts[connectorId].output,
            input: this.orchestratorStore.luts[connectorId].input,
            node: this.orchestratorStore.luts[connectorId].node,
            connector: this.orchestratorStore.luts[connectorId].connector,
            table: this.orchestratorStore.luts[connectorId].lut,
        };
    });
    // adding a connector
    if (this.orchestratorStore.hoveredPort && !this.inputStore.mouse.lmb && mouse.lmb && !this.orchestratorStore.movingConnector && this.orchestratorStore.hoveredPort.type === "output" && !locked) {
        this.orchestratorStore.addingConnector = this.orchestratorStore.hoveredPort;
        this.orchestratorStore.addingConnector.connector = {
            id: newId(),
            nodeId: null,
            field: null,
            graphId: null,
            version: null,
        };
    }
    // moving a connector
    if (this.orchestratorStore.hoveredConnector && !this.inputStore.mouse.lmb && mouse.lmb && pastDeadZone && !locked) {
        this.orchestratorStore.movingConnector = this.orchestratorStore.hoveredConnector;
    }
    // draw select box maybe
    if (this.graphCanvasStore.selectionRect.visible ||
        (      !this.orchestratorStore.hoveredConnector
            && !this.orchestratorStore.movingConnector
            && pastDeadZone
            && !this.graphCanvasStore.hoveredNode
            && !this.orchestratorStore.hoveredPort
            && !this.orchestratorStore.addingConnector
            && !this.orchestratorStore.keys[spaceKeyCode]
            && this.graphCanvasStore.movingNodes.length === 0
        )) {
        if (mouse.lmb && this.graphCanvasStore.translating.mouse && !this.graphCanvasStore.translating.isMap) {
            this.graphCanvasStore.selectionRect.visible = true;
            let x = this.graphCanvasStore.translating.mouse.x - mouse.x;
            let y = this.graphCanvasStore.translating.mouse.y - mouse.y;
            this.graphCanvasStore.selectionRect.x =
                (Math.min(this.graphCanvasStore.translating.mouse.x, this.graphCanvasStore.translating.mouse.x - x) - this.graphCanvasStore.view.x) / this.graphCanvasStore.view.k;
            this.graphCanvasStore.selectionRect.y =
                (Math.min(this.graphCanvasStore.translating.mouse.y, this.graphCanvasStore.translating.mouse.y - y) - this.graphCanvasStore.view.y) / this.graphCanvasStore.view.k;
            this.graphCanvasStore.selectionRect.width = Math.abs(x) / this.graphCanvasStore.view.k;
            this.graphCanvasStore.selectionRect.height = Math.abs(y) / this.graphCanvasStore.view.k;
            this.graphCanvasStore.selectionRect.right = this.graphCanvasStore.selectionRect.x + this.graphCanvasStore.selectionRect.width;
            this.graphCanvasStore.selectionRect.bottom = this.graphCanvasStore.selectionRect.y + this.graphCanvasStore.selectionRect.height;
        } else if (this.graphCanvasStore.selectionRect.visible) {
            this.graphCanvasStore.selectionRect = {visible: false, x: 0, y: 0, height: 0, width: 0, right: 0, bottom: 0};
        }
    }
    // selection box is moving around, clear out the selection every move unless addkey is held
    if (this.graphCanvasStore.selectionRect.visible && !addKey && this.inputStore.mouse.lmb) {
        this.orchestratorStore.selectedConnectors = [];
        this.graphCanvasStore.selectedNodes = [];
    }
    this.orchestratorStore.connectorWarn = null;
    // check hits on the connector LUT to find connector selection and connection hovers
    this.orchestratorStore.hoveredConnector = null;
    for (let j = 0; j < luts.length; j += 1) {
        const t = luts[j].table;
        const connector = luts[j].connector;
        const node = luts[j].node;
        const input = luts[j].input;
        const output = luts[j].output;
        for (let i = 0; i < t.length; i += 1) {
            if ((t[i].x < x && t[i].x + m > x && t[i].y < y && t[i].y + m > y)
                || (t[i].x >= this.graphCanvasStore.selectionRect.x && t[i].x <= this.graphCanvasStore.selectionRect.x + this.graphCanvasStore.selectionRect.width
                && t[i].y >= this.graphCanvasStore.selectionRect.y && t[i].y <= this.graphCanvasStore.selectionRect.y + this.graphCanvasStore.selectionRect.height)) {
                // check if this connector should be selected as well as hovered
                if ((mouse.lmb && !this.inputStore.mouse.lmb) || this.graphCanvasStore.selectionRect.visible) {
                    // maybe remove the previous selection before adding this one
                    if (!(this.orchestratorStore.keys[shiftKeyCode] || this.orchestratorStore.keys[metaKeyCode] || this.orchestratorStore.keys[ctrlKeyCode])
                        && !this.graphCanvasStore.selectionRect.visible) {
                        this.orchestratorStore.selectedConnectors = [];
                    }
                    if (this.orchestratorStore.selectedConnectors.indexOf(connector) === -1) {
                        this.orchestratorStore.selectedConnectors.push(connector);
                    }
                }
                // don't hover other connectors while moving a connector
                if (!this.orchestratorStore.movingConnector && !this.graphCanvasStore.selectionRect.visible) {
                    this.orchestratorStore.hoveredConnector = {node, connector, input, output};
                }
                break;
            }
        }
    }
    // trying to move a connector to this port
    if (this.orchestratorStore.hoveredPort && this.orchestratorStore.movingConnector && !this.orchestratorStore.addingConnector && this.orchestratorStore.hoveredPort.type === "input") {
        const node = this.graphCanvasStore.graphSnapshot.nodes.find((v: Node) => v.id === this.orchestratorStore.movingConnector.output.node.id);
        const edge = node.edges.find((e: {field: string}) => e.field === this.orchestratorStore.movingConnector.output.field.name);
        const connector = edge.connectors.find((e: {id: string}) => e.id === this.orchestratorStore.movingConnector.connector.id);
        const typeA = this.orchestratorStore.movingConnector.field.type;
        const typeB = this.orchestratorStore.hoveredPort.field.type;
        const valid = typeA === typeB || (typeA === "Object" || typeB === "Object");
        const msg = "Cannot connect " + typeA + " to " + typeB;
        if (!valid) {
            this.orchestratorStore.connectorWarn = msg;
        }
        if (!mouse.lmb && this.inputStore.mouse.lmb) {
            if (valid) {
                connector.nodeId = this.orchestratorStore.hoveredPort.node.id;
                connector.field = this.orchestratorStore.hoveredPort.field.name;
                this.applyGraphChanges("Move Connector");
                this.orchestratorStore.movingConnector = null;
            } else {
                this.orchestratorStore.showError = true;
                this.orchestratorStore.error = msg;
            }
        }
    }
    // add a new connector to a port
    if (this.orchestratorStore.hoveredPort && this.orchestratorStore.addingConnector && this.orchestratorStore.hoveredPort.type === "input") {
        const node = this.graphCanvasStore.graphSnapshot.nodes.find((v: Node) => v.id === this.orchestratorStore.addingConnector.node.id);
        const edge = node.edges.find((e: {field: string}) => e.field === this.orchestratorStore.addingConnector.field.name);
        const connector = this.orchestratorStore.addingConnector.connector;
        const typeA = this.orchestratorStore.addingConnector.field.type;
        const typeB = this.orchestratorStore.hoveredPort.field.type;
        const valid = typeA === typeB || (typeA === "Object" || typeB === "Object");
        const msg = "Cannot connect " + typeA + " to " + typeB;
        if (!valid) {
            this.orchestratorStore.connectorWarn = msg;
        }
        if (!mouse.lmb && this.inputStore.mouse.lmb) {
            if (valid) {
                connector.field = this.orchestratorStore.hoveredPort.field.name;
                connector.nodeId = this.orchestratorStore.hoveredPort.node.id;
                connector.graphId = this.orchestratorStore.hoveredPort.node.graphId;
                connector.version = this.orchestratorStore.hoveredPort.node.version;
                edge.connectors.push(connector);
                if (node.linkedGraph) {
                    linkInnerNodeEdges(node, this.orchestratorStore.scheduler.instance);
                }
                this.applyGraphChanges("Add Connector");
                this.orchestratorStore.addingConnector = null;
            } else {
                this.orchestratorStore.showError = true;
                this.orchestratorStore.error = "Cannot connect " + typeA + " to " + typeB;
            }
        }
    }
    // drop moving nodes and connectors
    if (!mouse.lmb && this.inputStore.mouse.lmb && this.graphCanvasStore.movingNodes.length > 0) {
        this.graphCanvasStore.movingNodes = [];
        this.applyGraphChanges("Move Nodes");
        this.orchestratorStore.movingConnector = null;
        this.orchestratorStore.addingConnector = null;
        this.graphCanvasStore.translating = {};
    }
    // mouse button was just released on nothing and no addKey was pressed
    if (!mouse.lmb && this.inputStore.mouse.lmb && !this.graphCanvasStore.hoveredNode
        && !pastDeadZone && !this.orchestratorStore.hoveredConnector && !addKey) {
        this.orchestratorStore.selectedConnectors = [];
        this.graphCanvasStore.selectedNodes = [];
        this.orchestratorStore.primaryGroup = null;
        this.graphCanvasStore.selectedNode = null;
    }
    // start moving nodes
    if (!this.inputStore.mouse.lmb && mouse.lmb && this.graphCanvasStore.hoveredNode && this.graphCanvasStore.movingNodes.length === 0 && !locked) {
        const selected = this.remapNodes(this.graphCanvasStore.selectedNodes);
        if (selected.find((v: Node) => v.id === this.graphCanvasStore.hoveredNode.id)) {
            this.graphCanvasStore.movingNodes = [
                ...selected,
            ];
        } else {
            // node being moved is not part of the selection, so move it solo
            this.graphCanvasStore.movingNodes = [
                remapHovered(),
            ];
        }
        this.graphCanvasStore.groupNodes = [
            ...this.graphCanvasStore.movingNodes,
        ];
        expandGroupNodeArray(this.graphCanvasStore.movingNodes);
    } else {
        // add to node selection
        if (!mouse.lmb && this.inputStore.mouse.lmb && !pastDeadZone && this.graphCanvasStore.movingNodes.length === 0) {
            if (!addKey || !this.graphCanvasStore.hoveredNode) {
                this.graphCanvasStore.selectedNodes = [];
                this.orchestratorStore.selectedGroups = [];
            }
            if (this.graphCanvasStore.hoveredNode) {
                const v = this.graphCanvasStore.graph.nodes.find((v: Node) => v.id === this.graphCanvasStore.hoveredNode.id);
                if (this.graphCanvasStore.selectedNodes.map((v: Node) => v.id).indexOf(v.id) === -1) {
                    this.graphCanvasStore.selectedNodes.push(v);
                }
                this.graphCanvasStore.selectedNode = v;
            }
            if (this.graphCanvasStore.selectedNodes.length > 0) {
                this.graphCanvasStore.groupNodes = [
                    ...this.graphCanvasStore.selectedNodes,
                ];
                expandGroupNodeArray(this.graphCanvasStore.selectedNodes);
            }
        }
    }
    // when selectionRect is visible, add overlapping nodes to selection
    if (this.graphCanvasStore.selectionRect.visible) {
        this.graphCanvasStore.graph.nodes.forEach((v: Node) => {
            const el = document.getElementById("node-" + v.id);
            if (!el) {
                return;
            }
            const elRect = el.getBoundingClientRect();
            const rect = {
                x: (elRect.x - this.graphCanvasStore.view.x) / this.graphCanvasStore.view.k,
                y: (elRect.y - this.graphCanvasStore.view.y) / this.graphCanvasStore.view.k,
                bottom: ((elRect.y - this.graphCanvasStore.view.y) / this.graphCanvasStore.view.k) + (elRect.height / this.graphCanvasStore.view.k),
                right: ((elRect.x - this.graphCanvasStore.view.x) / this.graphCanvasStore.view.k) + (elRect.width / this.graphCanvasStore.view.k),
            };
            const sel = this.graphCanvasStore.selectionRect;
            if (rect.x < sel.right
                && rect.right > sel.x
                && rect.y < sel.bottom
                && rect.bottom > sel.y) {
                if (this.graphCanvasStore.selectedNodes.map((v: Node) => v.id).indexOf(v.id) === -1) {
                    this.graphCanvasStore.selectedNodes.push(v);
                }
                this.graphCanvasStore.selectedNode = v;
            }
        });
        expandGroupNodeArray(this.graphCanvasStore.selectedNodes);
    }
    // expand selected groups to include related groups, then add them to the selection
    if (this.graphCanvasStore.groupNodes.length === 1) {
        expandGroupNodeArray(this.graphCanvasStore.groupNodes);
        this.orchestratorStore.selectedGroups = this.graphCanvasStore.groupNodes;
        if (this.graphCanvasStore.groupNodes.length !== 1) {
            this.orchestratorStore.primaryGroup = this.graphCanvasStore.groupNodes[0].properties.groups[0];
        }
    }
    // translate view
    if (((this.orchestratorStore.keys[spaceKeyCode] || this.graphCanvasStore.translating.isMap) && mouse.lmb) || mouse.mmb) {
        mouse.event.preventDefault();
        const p = {
            x: this.graphCanvasStore.translating.view.x + (mouse.x - this.graphCanvasStore.translating.mouse.x),
            y: this.graphCanvasStore.translating.view.y + (mouse.y - this.graphCanvasStore.translating.mouse.y),
        };
        if (this.graphCanvasStore.translating.isMap) {
            p.x = this.graphCanvasStore.translating.view.x - ((mouse.x - this.graphCanvasStore.translating.mouse.x) * this.graphCanvasStore.mapScale * this.graphCanvasStore.view.k);
            p.y = this.graphCanvasStore.translating.view.y - ((mouse.y - this.graphCanvasStore.translating.mouse.y) * this.graphCanvasStore.mapScale * this.graphCanvasStore.view.k);
        }
        this.graphCanvasStore.view.x = p.x * 1;
        this.graphCanvasStore.view.y = p.y * 1;
    }
    // move nodes
    if (this.graphCanvasStore.movingNodes.length > 0 && !locked) {
        this.graphCanvasStore.movingNodes.forEach((movingNode: any) => {
            const node = this.graphCanvasStore.graphSnapshot.nodes.find((v: Node) => movingNode.id === v.id);
            const transNode = this.graphCanvasStore.translating.nodes.find((v: any) => movingNode.id === v.id);
            const x = transNode.properties.x + ((mouse.x - this.graphCanvasStore.translating.mouse.x) / this.graphCanvasStore.view.k);
            const y = transNode.properties.y + ((mouse.y - this.graphCanvasStore.translating.mouse.y) / this.graphCanvasStore.view.k);
            node.properties.x = Math.floor(x / gridSize) * gridSize;
            node.properties.y = Math.floor(y / gridSize) * gridSize;
        });
    }
    this.updateBoundingRect();
    // set state last so we can check this.inputStore.mouse/mouse diff
    this.inputStore.$patch({mouse});
    this.orchestratorStore.mouseMovements.push({time: Date.now(), mouse});
  }
}