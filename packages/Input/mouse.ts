const shiftKeyCode = 16;
const metaKeyCode = 91;
const ctrlKeyCode = 17;
const spaceKeyCode = 32;
import type {Node} from "@plastic-io/plastic-io";
import type {Store} from 'pinia';
import {linkInnerNodeEdges} from "@plastic-io/plastic-io";
import {newId} from "@plastic-io/graph-editor-vue3-utils";
import {useStore as useOrchestratorStore} from "@plastic-io/graph-editor-vue3-orchestrator";
import {useStore as useGraphStore} from "@plastic-io/graph-editor-vue3-graph";
import {useStore as usePreferencesStore} from "@plastic-io/graph-editor-vue3-preferences-provider";

import {useStore as useInputStore} from "./store";
export default class MouseAction {
    inputStore: any
    orchestratorStore: any
    graphStore: any
    preferencesStore: any
  constructor() {
      this.orchestratorStore = useOrchestratorStore();
      this.preferencesStore = usePreferencesStore();
      this.graphStore = useGraphStore();
  }
  remapNodes(arr: any) {
    return this.graphStore.graph.nodes.filter((v: any) => {
      return arr.find((vi: any) => v.id === vi.id);
    });
  }
  applyGraphChanges(description: string) {
    this.graphStore.updateGraphFromSnapshot(description);
  }
  mouse(state: any, graphState: any, inputState: any, mouse: any) {
    if (this.orchestratorStore.inRewindMode) {
        console.warn("No mouse based mutations during rewind mode");
        return;
    }
    const locked = this.orchestratorStore.presentation || this.orchestratorStore.locked;
    const ctrl = mouse.event.ctrlKey || mouse.event.metaKey;
    const shift = mouse.event.shiftKey;
    const gridSize = this.preferencesStore.preferences.snapToGrid && !shift ? this.preferencesStore.preferences.gridSize : 1;
    const addKey = shift || ctrl;
    const pastDeadZone = graphState.translating.mouse ? (Math.abs(mouse.x - graphState.translating.mouse.x) > 2
        || Math.abs(mouse.y - graphState.translating.mouse.y) > 2) : false;
    // TODO: This whole grouping thing seems suspect.
    // Might need to reimagine how it works.  Moving on.
    const expandGroupNodeArray = (arr: any[]) => {
        let addCount = 0;
        // gather items in related groups
        const groupIds: string[] = [];
        // HACK: sometimes this array is populated with an empty member, not sure why, needs a fix
        arr.filter(v => !!v).forEach((v: Node) => {
            groupIds.push(...v.properties.groups);
        });
        graphState.graph.nodes.forEach((v: Node) => {
            if (v.properties.groups.find((value: string) => groupIds.includes(value)) && arr.indexOf(v) === -1) {
                addCount += 1;
                arr.push(v);
            }
        });
        if (addCount > 0) {
            expandGroupNodeArray(arr);
        }
    };
    const remapHovered = () => {
        return graphState.graph.nodes.find((v: Node) => {
            return graphState.hoveredNode.id === v.id;
        });
    }
    // check if the mouse is hovering over any connectors using LUTs generated by bezier.ts plugin
    let x = (mouse.x - graphState.view.x) / graphState.view.k;
    let y = (mouse.y - graphState.view.y) / graphState.view.k;
    // margin
    let m = 5;
    // map LUTs for collions
    const luts = Object.keys(graphState.luts).map((connectorId: string) => {
        return {
            output: graphState.luts[connectorId].output,
            input: graphState.luts[connectorId].input,
            node: graphState.luts[connectorId].node,
            connector: graphState.luts[connectorId].connector,
            table: graphState.luts[connectorId].lut,
        };
    });
    // adding a connector
    if (graphState.hoveredPort && !inputState.mouse.lmb && mouse.lmb && !graphState.movingConnector && !locked) {
        graphState.ltrPct = graphState.hoveredPort.type === "output" ? 0 : 1;
        graphState.addingConnector = graphState.hoveredPort;
        graphState.addingConnector.connector = {
            id: newId(),
            nodeId: null,
            field: null,
            graphId: null,
            version: null,
        };
    }
    // moving a connector
    if (graphState.hoveredConnector && !inputState.mouse.lmb && mouse.lmb && !locked) {
        graphState.movingConnector = graphState.hoveredConnector;
    }
    // draw select box maybe
    if (graphState.selectionRect.visible ||
        (      !graphState.hoveredConnector
            && !graphState.movingConnector
            && pastDeadZone
            && !graphState.hoveredNode
            && !graphState.hoveredPort
            && !graphState.addingConnector
            && !inputState.keys[spaceKeyCode]
            && graphState.movingNodes.length === 0
        )) {
        if (mouse.lmb && graphState.translating.mouse && !graphState.translating.isMap) {
            graphState.selectionRect.visible = true;
            let x = graphState.translating.mouse.x - mouse.x;
            let y = graphState.translating.mouse.y - mouse.y;
            graphState.selectionRect.x =
                (Math.min(graphState.translating.mouse.x, graphState.translating.mouse.x - x) - graphState.view.x) / graphState.view.k;
            graphState.selectionRect.y =
                (Math.min(graphState.translating.mouse.y, graphState.translating.mouse.y - y) - graphState.view.y) / graphState.view.k;
            graphState.selectionRect.width = Math.abs(x) / graphState.view.k;
            graphState.selectionRect.height = Math.abs(y) / graphState.view.k;
            graphState.selectionRect.right = graphState.selectionRect.x + graphState.selectionRect.width;
            graphState.selectionRect.bottom = graphState.selectionRect.y + graphState.selectionRect.height;
        } else if (graphState.selectionRect.visible) {
            graphState.selectionRect = {visible: false, x: 0, y: 0, height: 0, width: 0, right: 0, bottom: 0};
        }
    }
    // selection box is moving around, clear out the selection every move unless addkey is held
    if (graphState.selectionRect.visible && !addKey && inputState.mouse.lmb) {
        graphState.selectedConnectors = [];
        graphState.selectedNodes = [];
    }
    graphState.connectorWarn = null;
    // check hits on the connector LUT to find connector selection and connection hovers
    graphState.hoveredConnector = null;
    if (!graphState.addingConnector) {
        for (let j = 0; j < luts.length; j += 1) {
            const t = luts[j].table;
            const connector = luts[j].connector;
            const node = luts[j].node;
            const input = luts[j].input;
            const output = luts[j].output;
            for (let i = 0; i < t.length; i += 1) {
                if ((t[i].x < x && t[i].x + m > x && t[i].y < y && t[i].y + m > y)
                    || (t[i].x >= graphState.selectionRect.x && t[i].x <= graphState.selectionRect.x + graphState.selectionRect.width
                    && t[i].y >= graphState.selectionRect.y && t[i].y <= graphState.selectionRect.y + graphState.selectionRect.height)) {
                    // left to right % of the hit
                    if (!graphState.movingConnector && !graphState.addingConnector) {
                        graphState.ltrPct = i / t.length;
                    }
                    // check if state connector should be selected as well as hovered
                    if ((mouse.lmb && !inputState.mouse.lmb) || graphState.selectionRect.visible) {
                        // maybe remove the previous selection before adding state one
                        if (!(inputState.keys[shiftKeyCode] || inputState.keys[metaKeyCode] || inputState.keys[ctrlKeyCode])
                            && !graphState.selectionRect.visible) {
                            graphState.selectedConnectors = [];
                        }
                        if (graphState.selectedConnectors.indexOf(connector) === -1) {
                            graphState.selectedConnectors.push(connector);
                        }
                    }
                    // don't hover other connectors while moving a connector
                    if (!graphState.movingConnector && !graphState.selectionRect.visible) {
                        graphState.hoveredConnector = {node, connector, input, output};
                    }
                    break;
                }
            }
        }
    }
    // trying to move a connector to state port
    if (graphState.hoveredPort && graphState.movingConnector && !graphState.addingConnector) {
        // if the user grabbed the left side of the connector, connect from right to left, else left to right (ltr).
        const ltr = graphState.ltrPct > 0.5;
        const io =  ltr ? 'output' : 'input';
        const rio =  !ltr ? 'output' : 'input';
        // hovering over the right type of port input vs. output
        if (graphState.hoveredPort.type === rio) {
            // edge is always defined on the output
            const node = graphState.graphSnapshot.nodes.find((v: Node) => v.id === graphState.movingConnector.output.node.id);
            const edge = node.edges.find((e: {field: string}) => e.field === graphState.movingConnector.output.field.name);
            const connector = edge.connectors.find((e: {id: string}) => e.id === graphState.movingConnector.connector.id);
            const typeA = graphState.movingConnector[io].field.type;
            const typeB = graphState.hoveredPort.field.type;
            const valid = typeA === typeB || (typeA === "Object" || typeB === "Object");
            const msg = "Cannot connect " + typeA + " to " + typeB;
            if (!valid) {
                graphState.connectorWarn = msg;
            }
            if (!mouse.lmb && inputState.mouse.lmb) {
                if (valid) {
                    if (ltr) {
                        // if changing the target of an output (ltr), just change the connector fields
                        connector.nodeId = graphState.hoveredPort.node.id;
                        connector.field = graphState.hoveredPort.field.name;
                    } else {
                        // if changing output to another output, delete state connector
                        const rmCon = edge.connectors.find((c: any) => {
                            return connector.field === c.field;
                        });
                        edge.connectors.splice(edge.connectors.indexOf(rmCon), 1);
                        // and add it to a new edge
                        connector.nodeId = graphState.movingConnector.input.node.id;
                        connector.field = graphState.movingConnector.input.field.name;
                        graphState.hoveredPort.edge.connectors.push(connector);
                    }
                    this.applyGraphChanges("Move Connector");
                    graphState.movingConnector = null;
                } else {
                    this.orchestratorStore.showError = true;
                    this.orchestratorStore.error = msg;
                }
            }
        }
    }
    // add a new connector to a port
    if (graphState.hoveredPort && graphState.addingConnector
            && graphState.addingConnector.node.id !== graphState.hoveredPort.node.id) {
        
        const node = graphState.graphSnapshot.nodes.find((v: Node) => v.id === graphState.addingConnector.node.id);
        const edge = node.edges.find((e: {field: string}) => e.field === graphState.addingConnector.field.name);
        const connector = graphState.addingConnector.connector;
        const typeA = graphState.addingConnector.field.type;
        const typeB = graphState.hoveredPort.field.type;
        const valid = typeA === typeB || (typeA === "Object" || typeB === "Object");
        const msg = "Cannot connect " + typeA + " to " + typeB;
        if (!valid) {
            graphState.connectorWarn = msg;
        }
        if (!mouse.lmb && inputState.mouse.lmb) {
            if (valid) {
                if (graphState.hoveredPort.type === "input" && graphState.addingConnector.type === 'output') {
                    connector.field = graphState.hoveredPort.field.name;
                    connector.nodeId = graphState.hoveredPort.node.id;
                    connector.graphId = graphState.hoveredPort.node.graphId;
                    connector.version = graphState.hoveredPort.node.version;
                    edge.connectors.push(connector);
                    if (node.linkedGraph) {
                        linkInnerNodeEdges(node, graphState.scheduler.instance);
                    }
                } else if (graphState.hoveredPort.type === "output" && graphState.addingConnector.type === 'input') {
                    // add connector to the hovered port's node
                    const node = graphState.graphSnapshot.nodes.find((v: Node) => v.id === graphState.hoveredPort.node.id);
                    const edge = node.edges.find((e: {field: string}) => e.field === graphState.hoveredPort.field.name);
                    connector.field = graphState.addingConnector.field.name;
                    connector.nodeId = graphState.addingConnector.node.id;
                    connector.graphId = graphState.addingConnector.node.graphId;
                    connector.version = graphState.addingConnector.node.version;
                    edge.connectors.push(connector);
                }
                this.applyGraphChanges("Add Connector");
                graphState.addingConnector = null;
            } else {
                this.orchestratorStore.showError = true;
                this.orchestratorStore.error = "Cannot connect " + typeA + " to " + typeB;
            }
        }
    }
    // drop moving nodes and connectors
    if (!mouse.lmb && inputState.mouse.lmb &&
        (graphState.movingNodes.length > 0
            || graphState.movingConnector !== null
            || graphState.addingConnector !== null
        )) {
        if (graphState.movingNodes.length > 0) {
            graphState.movingNodes = [];
            if (pastDeadZone) {
                this.applyGraphChanges("Move Nodes");
            }
        }
        if (graphState.movingConnector && pastDeadZone) {
            // delete moving connector if it didn't find a home
            const edge = graphState.movingConnector.output.node.edges.find((edge: any) => {
                return edge.field === graphState.movingConnector.output.field.name;
            });
            const rmCon = edge.connectors.find((c: any) => {
                return c.field === graphState.movingConnector.output.field.name;
            });
            edge.connectors.splice(edge.connectors.indexOf(rmCon), 1);
            graphState.movingConnector = null;
        }
        if (graphState.addingConnector) {
            graphState.addingConnector = null;
        }
        graphState.translating = {};
    }
    // mouse button was just released on nothing and no addKey was pressed
    if (!mouse.lmb && inputState.mouse.lmb && !graphState.hoveredNode
        && !pastDeadZone && !graphState.hoveredConnector && !addKey) {
        graphState.selectedConnectors = [];
        graphState.selectedNodes = [];
        graphState.primaryGroup = null;
        graphState.selectedNode = null;
    }
    // start moving nodes
    if (!inputState.mouse.lmb && mouse.lmb && graphState.hoveredNode && graphState.movingNodes.length === 0 && !locked) {
        const selected = this.remapNodes(graphState.selectedNodes);
        if (selected.find((v: Node) => v.id === graphState.hoveredNode.id)) {
            graphState.movingNodes = [
                ...selected,
            ];
        } else {
            // node being moved is not part of the selection, so move it solo
            graphState.movingNodes = [
                remapHovered(),
            ];
        }
        graphState.groupNodes = [
            ...graphState.movingNodes,
        ];
        expandGroupNodeArray(graphState.movingNodes);
    } else {
        // add to node selection
        if (!mouse.lmb && inputState.mouse.lmb && !pastDeadZone && graphState.movingNodes.length === 0) {
            if (!addKey || !graphState.hoveredNode) {
                graphState.selectedNodes = [];
                graphState.selectedGroups = [];
            }
            if (graphState.hoveredNode) {
                const v = graphState.graph.nodes.find((v: Node) => v.id === graphState.hoveredNode.id);
                if (graphState.selectedNodes.map((v: Node) => v.id).indexOf(v.id) === -1) {
                    graphState.selectedNodes.push(v);
                }
                graphState.selectedNode = v;
            }
            if (graphState.selectedNodes.length > 0) {
                graphState.groupNodes = [
                    ...graphState.selectedNodes,
                ];
                expandGroupNodeArray(graphState.selectedNodes);
            }
        }
    }
    // when selectionRect is visible, add overlapping nodes to selection
    if (graphState.selectionRect.visible) {
        graphState.graph.nodes.forEach((v: Node) => {
            const el = document.getElementById("node-" + v.id);
            if (!el) {
                return;
            }
            const elRect = el.getBoundingClientRect();
            const rect = {
                x: (elRect.x - graphState.view.x) / graphState.view.k,
                y: (elRect.y - graphState.view.y) / graphState.view.k,
                bottom: ((elRect.y - graphState.view.y) / graphState.view.k) + (elRect.height / graphState.view.k),
                right: ((elRect.x - graphState.view.x) / graphState.view.k) + (elRect.width / graphState.view.k),
            };
            const sel = graphState.selectionRect;
            if (rect.x < sel.right
                && rect.right > sel.x
                && rect.y < sel.bottom
                && rect.bottom > sel.y) {
                if (graphState.selectedNodes.map((v: Node) => v.id).indexOf(v.id) === -1) {
                    graphState.selectedNodes.push(v);
                }
                graphState.selectedNode = v;
            }
        });
        expandGroupNodeArray(graphState.selectedNodes);
    }
    // expand selected groups to include related groups, then add them to the selection
    if (graphState.groupNodes.length === 1) {
        expandGroupNodeArray(graphState.groupNodes);
        graphState.selectedGroups = graphState.groupNodes;
        if (graphState.groupNodes.length !== 1) {
            graphState.primaryGroup = graphState.groupNodes[0].properties.groups[0];
        }
    }
    // translate view
    if (((inputState.keys[spaceKeyCode] || graphState.translating.isMap) && mouse.lmb) || mouse.mmb) {
        mouse.event.preventDefault();
        const p = {
            x: graphState.translating.view.x + (mouse.x - graphState.translating.mouse.x),
            y: graphState.translating.view.y + (mouse.y - graphState.translating.mouse.y),
        };
        if (graphState.translating.isMap) {
            p.x = graphState.translating.view.x - ((mouse.x - graphState.translating.mouse.x) * graphState.mapScale * graphState.view.k);
            p.y = graphState.translating.view.y - ((mouse.y - graphState.translating.mouse.y) * graphState.mapScale * graphState.view.k);
        }
        graphState.view.x = p.x * 1;
        graphState.view.y = p.y * 1;
    }
    // move nodes
    if (graphState.movingNodes.length > 0 && !locked) {
        graphState.movingNodes.forEach((movingNode: any) => {
            const node = graphState.graphSnapshot.nodes.find((v: Node) => movingNode.id === v.id);
            const transNode = graphState.translating.nodes.find((v: any) => movingNode.id === v.id);
            const x = transNode.properties.x + ((mouse.x - graphState.translating.mouse.x) / graphState.view.k);
            const y = transNode.properties.y + ((mouse.y - graphState.translating.mouse.y) / graphState.view.k);
            node.properties.x = Math.floor(x / gridSize) * gridSize;
            node.properties.y = Math.floor(y / gridSize) * gridSize;
        });
    }
    this.graphStore.updateBoundingRect();
    // set state last so we can check inputState.mouse/mouse diff
    inputState.mouse = mouse;
  }
}
